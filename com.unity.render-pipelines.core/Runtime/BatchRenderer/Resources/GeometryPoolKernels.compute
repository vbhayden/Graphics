#pragma kernel MainUpdateIndexBuffer16
#pragma kernel MainUpdateIndexBuffer32
#pragma kernel MainUpdateVertexBuffer

#include "Packages/com.unity.render-pipelines.core/Runtime/BatchRenderer/Resources/GeometryPoolDefs.cs.hlsl"

//#pragma enable_d3d11_debug_symbols

#define _InputIBOffset  0

#define GROUP_SIZE_X 64
#define GROUP_SIZE_X_HALF (GROUP_SIZE_X >> 1)

int _InputIBCount;
int _OutputIBOffset;
int _GeoHandle;
int _GeoVertexOffset;

ByteAddressBuffer _InputIndexBuffer;
RWByteAddressBuffer _OutputIndexBuffer;
RWStructuredBuffer<GeoPoolMetadataEntry> _OutputGeoMetadataBuffer;

[numthreads(GROUP_SIZE_X,1,1)]
void MainUpdateIndexBuffer32(uint3 dispatchThreadID : SV_DispatchThreadID, int3 groupID : SV_GroupID)
{
    if (groupID.x == 0)
    {
        GeoPoolMetadataEntry entry;
        entry.vertexOffset = _GeoVertexOffset;
        _OutputGeoMetadataBuffer[_GeoHandle] = entry;
    }

    uint bufferOffset = dispatchThreadID.x;
    if (bufferOffset >= (uint)_InputIBCount)
        return;

    uint storageAddress = ((uint)_OutputIBOffset + bufferOffset) << 2u;
    _OutputIndexBuffer.Store(storageAddress, _InputIndexBuffer.Load((_InputIBOffset + bufferOffset) << 2u));
}

groupshared uint _ldsIndexCache[GROUP_SIZE_X >> 1];

[numthreads(GROUP_SIZE_X,1,1)]
void MainUpdateIndexBuffer16(uint3 dispatchThreadID : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint3 groupID : SV_GroupID)
{
    if (groupID.x == 0)
    {
        GeoPoolMetadataEntry entry;
        entry.vertexOffset = _GeoVertexOffset;
        _OutputGeoMetadataBuffer[_GeoHandle] = entry;
    }

    //only load half the data.
    if (groupIndex < GROUP_SIZE_X_HALF)
        _ldsIndexCache[groupIndex] = _InputIndexBuffer.Load((GROUP_SIZE_X_HALF * groupID.x + groupIndex) << 2u);

    GroupMemoryBarrierWithGroupSync();

    uint bufferOffset = dispatchThreadID.x;
    if (bufferOffset >= (uint)_InputIBCount)
        return;

    uint pair = _ldsIndexCache[groupIndex >> 1u];
    uint value = (groupIndex.x & 0x1) ? (pair >> 16) : (pair & 0xffff);

    uint storageAddress = ((uint)_OutputIBOffset + bufferOffset) << 2;
    _OutputIndexBuffer.Store(storageAddress, value);
} 

int _InputVBCount;
int _OutputVBSize;
int _OutputVBOffset;

int _InputPosBufferStride;
int _InputPosBufferOffset;

int _InputUv0BufferStride;
int _InputUv0BufferOffset;

int _InputUv1BufferStride;
int _InputUv1BufferOffset;

int _InputNormalBufferStride;
int _InputNormalBufferOffset;

int _InputTangentBufferStride;
int _InputTangentBufferOffset;

int _InputFlags;

ByteAddressBuffer _PosBuffer;
ByteAddressBuffer _Uv0Buffer;
ByteAddressBuffer _Uv1Buffer;
ByteAddressBuffer _NormalBuffer;
ByteAddressBuffer _TangentBuffer;

RWByteAddressBuffer _OutputVB;

void StoreVertex(
    int vertexIndex,
    in GeometryPoolVertex vertex,
    int vertexFlags,
    int outputBufferSize,
    RWByteAddressBuffer output)
{
    int componentOffset = outputBufferSize * GEO_POOL_POS_BYTE_OFFSET;
    output.Store3(componentOffset + vertexIndex * GEO_POOL_POS_BYTE_SIZE, asuint(vertex.pos));

    componentOffset = outputBufferSize * GEO_POOL_UV0BYTE_OFFSET;
    output.Store2(componentOffset + vertexIndex * GEO_POOL_UV0BYTE_SIZE, asuint(vertex.uv));

    componentOffset = outputBufferSize * GEO_POOL_UV1BYTE_OFFSET;
    if ((vertexFlags & GEOPOOLINPUTFLAGS_HAS_UV1) != 0)
        output.Store2(componentOffset + vertexIndex * GEO_POOL_UV1BYTE_SIZE, asuint(vertex.uv1));

    componentOffset = outputBufferSize * GEO_POOL_NORMAL_BYTE_OFFSET;
    output.Store3(componentOffset + vertexIndex * GEO_POOL_NORMAL_BYTE_SIZE, asuint(vertex.N));

    componentOffset = outputBufferSize * GEO_POOL_TANGENT_BYTE_OFFSET;
    if ((vertexFlags & GEOPOOLINPUTFLAGS_HAS_TANGENT) != 0)
        output.Store2(componentOffset + vertexIndex * GEO_POOL_TANGENT_BYTE_SIZE, asuint(vertex.T));
}

[numthreads(GROUP_SIZE_X, 1, 1)]
void MainUpdateVertexBuffer(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int vertexOffset = (int)dispatchThreadID.x;
    if (vertexOffset >= _InputVBCount)
        return;

    GeometryPoolVertex vtx;
    vtx.pos = asfloat(_PosBuffer.Load3(_InputPosBufferOffset + (vertexOffset * _InputPosBufferStride)));
    vtx.uv  = asfloat(_Uv0Buffer.Load2(_InputUv0BufferOffset + (vertexOffset * _InputUv0BufferStride)));
        
    if ((_InputFlags & GEOPOOLINPUTFLAGS_HAS_UV1) != 0)
        vtx.uv1 = asfloat(_Uv1Buffer.Load2(_InputUv1BufferOffset + (vertexOffset * _InputUv1BufferStride)));
    else
        vtx.uv1 = float2(0, 0);

    vtx.N = asfloat(_NormalBuffer.Load3(_InputNormalBufferOffset + (vertexOffset * _InputNormalBufferStride)));

    if ((_InputFlags & GEOPOOLINPUTFLAGS_HAS_TANGENT) != 0)
        vtx.T = asfloat(_TangentBuffer.Load3(_InputTangentBufferOffset + (vertexOffset * _InputTangentBufferStride)));
    else
        vtx.T = float3(0, 0, 0);

    StoreVertex(_OutputVBOffset + vertexOffset, vtx, _InputFlags, _OutputVBSize, _OutputVB);
}
